{"name": "test_exit_all", "status": "broken", "statusDetails": {"message": "TypeError: catching classes that do not inherit from BaseException is not allowed", "trace": "address = ('localhost', 54672), timeout = 1, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               TimeoutError: timed out\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\socket.py:833: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = DriverEngine(screen='IntroPage')\n\n    def teardown(self) -> None:\n        try:\n            self.driver.close()\n>           self.driver.quit()\n\n..\\core\\infrastructure\\driver\\engine.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.chrome.webdriver.WebDriver (session=\"78e3fb8bf33ef638ccafb4dbaf68a9f1\")>\n\n    def quit(self) -> None:\n        \"\"\"Closes the browser and shuts down the ChromiumDriver executable that\n        is started when starting the ChromiumDriver.\"\"\"\n        try:\n            super().quit()\n        except Exception:\n            # We don't care about the message because something probably has gone wrong\n            pass\n        finally:\n>           self.service.stop()\n\n..\\venv\\lib\\site-packages\\selenium\\webdriver\\chromium\\webdriver.py:194: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.chrome.service.Service object at 0x000001C7E780E800>\n\n    def stop(self) -> None:\n        \"\"\"Stops the service.\"\"\"\n        if self.log_file != PIPE and not (self.log_file == DEVNULL):\n            try:\n                # Todo: Be explicit in what we are catching here.\n                if hasattr(self.log_file, \"close\"):\n                    self.log_file.close()  # type: ignore\n            except Exception:\n                pass\n    \n        if self.process is not None:\n            try:\n>               self.send_remote_shutdown_command()\n\n..\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:142: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.chrome.service.Service object at 0x000001C7E780E800>\n\n    def send_remote_shutdown_command(self) -> None:\n        \"\"\"Dispatch an HTTP request to the shutdown endpoint for the service in\n        an attempt to stop it.\"\"\"\n        try:\n            request.urlopen(f\"{self.service_url}/shutdown\")\n        except URLError:\n            return\n    \n        for _ in range(30):\n>           if not self.is_connectable():\n\n..\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.chrome.service.Service object at 0x000001C7E780E800>\n\n    def is_connectable(self) -> bool:\n        \"\"\"Establishes a socket connection to determine if the service running\n        on the port is accessible.\"\"\"\n>       return utils.is_connectable(self.port)\n\n..\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:115: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nport = 54672, host = 'localhost'\n\n    def is_connectable(port: int, host: Optional[str] = \"localhost\") -> bool:\n        \"\"\"Tries to connect to the server at port to see if it is running.\n    \n        :Args:\n         - port - The port to connect.\n        \"\"\"\n        socket_ = None\n        try:\n>           socket_ = socket.create_connection((host, port), 1)\n\n..\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\utils.py:102: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 54672), timeout = 1, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               KeyboardInterrupt\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\socket.py:833: KeyboardInterrupt\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_intro_page.TestIntroPage object at 0x000001C7E7874040>\n\n    def test_exit_all(self) -> None:\n>       self.engine.teardown()\n\ngoogle\\test_intro_page.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = DriverEngine(screen='IntroPage')\n\n    def teardown(self) -> None:\n        try:\n            self.driver.close()\n            self.driver.quit()\n>       except self.driver is None:\nE       TypeError: catching classes that do not inherit from BaseException is not allowed\n\n..\\core\\infrastructure\\driver\\engine.py:220: TypeError"}, "start": 1687784119578, "stop": 1687784121829, "uuid": "6a4ba715-8bee-4ccd-b0de-c2b83768f425", "historyId": "71084425ced3e7852b51d5d75a8206a2", "testCaseId": "71084425ced3e7852b51d5d75a8206a2", "fullName": "google.test_intro_page.TestIntroPage#test_exit_all", "labels": [{"name": "parentSuite", "value": "google"}, {"name": "suite", "value": "test_intro_page"}, {"name": "subSuite", "value": "TestIntroPage"}, {"name": "host", "value": "IL-EVGENYP-LP"}, {"name": "thread", "value": "15248-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "google.test_intro_page"}]}